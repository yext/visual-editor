import fs from "fs";
import path from "path";
import { ApiModel } from "@microsoft/api-extractor-model";

// path for api json generated by api-extractor
const API_JSON_PATH = path.join("temp", "visual-editor.api.json");
const OUTPUT_PATH = path.join("src", "docs", "components.md");
// path for all components screenshots used in testing
const SCREENSHOTS_BASE_DIR = path.join(
  "src",
  "components",
  "testing",
  "screenshots"
);

/**
 * Recursively renders a TSDoc node tree into a plain string.
 * @param {object} docNode - The TSDoc node to render.
 * @returns {string} The rendered string content.
 */
function renderTsDocNode(docNode) {
  if (!docNode) {
    return "";
  }

  switch (docNode.kind) {
    case "PlainText":
      return docNode.text;
    case "SoftBreak":
      return "\n";
    case "Section":
      return docNode.getChildNodes().map(renderTsDocNode).join("\n\n");
    default:
      return docNode.getChildNodes().map(renderTsDocNode).join("");
  }
}

/**
 * Extracts the summary section from an API item's TSDoc comment.
 * @param {object} apiItem - The API item from api-extractor.
 * @returns {string} The summary text, or an empty string if none exists.
 */
function getSummary(apiItem) {
  if (!apiItem?.tsdocComment) {
    return "";
  }
  return renderTsDocNode(apiItem.tsdocComment.summarySection).trim();
}

/**
 * Gets the value of a custom TSDoc block tag (e.g. @propCategory).
 * @param {object} apiItem - The API item.
 * @param {string} tagName - The name of the custom tag to find.
 * @returns {string} The content of the custom tag, or an empty string.
 */
function getCustomTagValue(apiItem, tagName) {
  if (!apiItem?.tsdocComment) {
    return "";
  }
  const block = apiItem.tsdocComment.customBlocks.find(
    (b) => b.blockTag.tagName.toUpperCase() === tagName.toUpperCase()
  );
  return block ? renderTsDocNode(block.content).trim() : "";
}

/**
 * Gets the @defaultValue tag value for a prop.
 * @param {object} apiItem - The API item.
 * @returns {string} The default value or empty string.
 */
function getDefaultValue(apiItem) {
  return getCustomTagValue(apiItem, "@defaultValue");
}

/**
 * Formats a TypeScript type string for display in a Markdown table.
 * @param {object} apiProperty - The API property item.
 * @returns {string} The cleaned and escaped type string.
 */
function formatType(apiProperty) {
  return apiProperty.propertyTypeExcerpt.text
    .replace(/\s+/g, " ")
    .replace(/\|/g, "\\|")
    .trim();
}

/**
 * Finds the first PNG testing screenshot for a component and returns its Markdown image tag.
 * @param {string} componentName - The name of the component.
 * @returns {string} A Markdown image string or an empty string if not found.
 */
function getComponentImageMarkdown(componentName) {
  const screenshotsDir = path.join(SCREENSHOTS_BASE_DIR, componentName);

  if (!fs.existsSync(screenshotsDir)) {
    return "";
  }

  try {
    const files = fs.readdirSync(screenshotsDir);
    const firstPng = files.find((file) => file.toLowerCase().endsWith(".png"));

    if (firstPng) {
      const fullImagePath = path.join(screenshotsDir, firstPng);
      // Get the relative path from the output doc to the image.
      const relativePath = path
        .relative(path.dirname(OUTPUT_PATH), fullImagePath)
        .replace(/\\/g, "/"); // Ensure forward slashes for web paths.

      return `![Preview of the ${componentName} component](${encodeURI(relativePath)})\n\n`;
    }
  } catch {
    // Do nothing
  }

  return "";
}

/**
 * Generates a Markdown table for a component's props, grouped by category.
 * @param {string} propsTypeName - The name of the props interface (e.g. "BannerSectionProps").
 * @param {Map} allInterfaces - A map of all interface definitions found.
 * @returns {string} The complete Markdown for the props section.
 */
function generatePropsTableMarkdown(propsTypeName, allInterfaces) {
  const propsInterface = allInterfaces.get(propsTypeName);
  if (!propsInterface) {
    return "";
  }

  const intro = getSummary(propsInterface);
  let markdown = `### Props\n\n`;
  if (intro) {
    markdown += `${intro}\n\n`;
  }

  // Group props using the @propCategory tag.
  const categories = new Map();

  for (const prop of propsInterface.members) {
    if (prop.kind !== "PropertySignature") {
      continue;
    }

    // Default to "Other Props" if no category is specified.
    const category = getCustomTagValue(prop, "@propCategory") || "Other Props";
    if (!categories.has(category)) {
      // Initialize the category with its description
      categories.set(category, { description: getSummary(prop), props: [] });
    }
    categories.get(category).props.push(prop);
  }

  // Sort categories putting "Other Props" last.
  const sortedCategories = Array.from(categories.entries()).sort(([a], [b]) => {
    if (a === "Other Props") {
      return 1;
    }
    if (b === "Other Props") {
      return -1;
    }
    return a.localeCompare(b);
  });

  // Build the Markdown table for each category.
  for (const [categoryName, { description, props }] of sortedCategories) {
    markdown += `#### ${categoryName}\n\n`;

    if (description) {
      markdown += `${description}\n\n`;
    }

    markdown += "| Prop | Type | Description | Default |\n";
    markdown += "|:-----|:-----|:------------|:--------|\n";

    for (const prop of props) {
      const propType = formatType(prop);
      // Check if the prop's type is another interface we should expand.
      const subInterface = allInterfaces.get(propType.replace(/\[|\]/g, ""));

      // Expand nested interfaces (e.g. BannerData)
      if (subInterface) {
        // Render a row for each property of the nested interface.
        for (const subProp of subInterface.members) {
          if (subProp.kind !== "PropertySignature") {
            continue;
          }

          // Prefix the prop name, e.g., "data.text".
          const qualifiedName = `${prop.displayName}.${subProp.displayName}`;

          const row = `| \`${qualifiedName}\` | \`${formatType(subProp)}\` | ${getSummary(subProp)} | ${getDefaultValue(subProp) ? `\`${getDefaultValue(subProp)}\`` : ""} |\n`;
          markdown += row;
        }
      } else {
        // Render a single row for non-nested property (e.g. "liveVisibility")
        const row = `| \`${prop.displayName}\` | \`${propType}\` | ${getSummary(prop)} | ${getDefaultValue(prop) ? `\`${getDefaultValue(prop)}\`` : ""} |\n`;
        markdown += row;
      }
    }
    markdown += "\n";
  }

  return markdown;
}

/**
 * Main function to generate the entire component documentation Markdown file.
 */
function generateMarkdown() {
  // Load and parse the API data generated by api-extractor.
  const apiModel = new ApiModel();
  const apiPackage = apiModel.loadPackage(API_JSON_PATH);
  const entryPoint = apiPackage.members[0];

  // Create a map of all interfaces by their display name.
  const allInterfaces = new Map(
    entryPoint.members
      .filter((m) => m.kind === "Interface")
      .map((i) => [i.displayName, i])
  );

  // Start with the VitePress frontmatter.
  let markdown = `---\ntitle: Pre-Built Components\noutline: 2\n---\n\n`;

  // Iterate over all exports to find the component configurations.
  for (const apiMember of entryPoint.members) {
    // Find variables whose type is `ComponentConfig<...>`
    if (
      apiMember.kind !== "Variable" ||
      !apiMember.variableTypeExcerpt.text.startsWith("ComponentConfig")
    ) {
      continue;
    }

    // Extract the props type name from the <> (e.g. "BannerSectionProps").
    const match = /<(\w+)>/.exec(apiMember.variableTypeExcerpt.text);
    const propsTypeName = match?.[1];
    if (!propsTypeName || !allInterfaces.has(propsTypeName)) {
      continue;
    }

    const componentName = apiMember.displayName;
    const summary = getSummary(apiMember);
    const imageMarkdown = getComponentImageMarkdown(componentName);
    const propsTableMarkdown = generatePropsTableMarkdown(
      propsTypeName,
      allInterfaces
    );

    markdown += `## ${componentName}\n\n`;
    if (summary) {
      markdown += `${summary}\n\n`;
    }
    markdown += imageMarkdown;
    markdown += propsTableMarkdown;
    markdown += "\n---\n\n"; // Separator for the next component.
  }

  fs.writeFileSync(OUTPUT_PATH, markdown);
  console.log(`‚úÖ Successfully created API documentation at ${OUTPUT_PATH}`);
}

/**
 * Removes temporary files and directories created during the generate docs process.
 */
function cleanup() {
  console.log("üßπ Cleaning up intermediate build files...");
  try {
    for (const dir of ["temp"]) {
      fs.rmSync(dir, { recursive: true, force: true });
    }
    console.log("üëç Cleanup complete.");
  } catch (error) {
    console.error("Error during cleanup:", error);
  }
}

try {
  generateMarkdown();
} finally {
  cleanup();
}
