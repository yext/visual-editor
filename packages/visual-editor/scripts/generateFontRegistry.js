import fs from "fs";
import path from "path";
import prettier from "prettier";
import { allowedFonts } from "./allowedFonts.js";

const GOOGLE_FONTS_API_KEY = process.argv[2]; // Replace with your Google Fonts API key
if (!GOOGLE_FONTS_API_KEY) {
  console.error(
    "Error: No API key provided. Usage: node generateFontRegistry.js YOUR_API_KEY"
  );
  process.exit(1);
}

console.log("Using API key:", GOOGLE_FONTS_API_KEY);

const OUTPUT_FILE = path.join(
  process.cwd(),
  "src",
  "utils",
  "font_registry.js"
);

const fallbackFromCategory = (category) => {
  switch (category) {
    case "serif":
      return "serif";
    case "monospace":
      return "monospace";
    case "handwriting":
      return "cursive";
    case "display":
    case "sans-serif":
    default:
      return "sans-serif";
  }
};

const getFontData = async () => {
  const url = `https://www.googleapis.com/webfonts/v1/webfonts?key=${GOOGLE_FONTS_API_KEY}&sort=alpha&capability=VF`;
  const response = await fetch(url);
  if (!response.ok) throw new Error(`API request failed: ${response.status}`);
  const data = await response.json();
  return data.items;
};

const parseFontDetails = (font) => {
  const variants = font.variants;

  const hasItalic = variants.some((v) => v.includes("italic"));

  if ("axes" in font) {
    const wghtTag = font.axes.find((dim) => dim.tag === "wght");

    return {
      italics: hasItalic,
      minWeight: wghtTag.start,
      maxWeight: wghtTag.end,
      fallback: fallbackFromCategory(font.category),
    };
  }

  // Extract weights (some variants are like 'regular' which is 400)
  const weights = variants
    .map((v) => {
      if (v === "regular" || v === "italic") return 400;
      const match = v.match(/^(\d+)/);
      return match ? parseInt(match[1], 10) : NaN;
    })
    .filter((w) => !isNaN(w));

  if (weights.length === 0) {
    weights.push(400);
  }

  return {
    italics: hasItalic,
    weights: [...new Set(weights)], // remove duplicates
    fallback: fallbackFromCategory(font.category),
  };
};

const buildFontRegistry = async () => {
  const fonts = await getFontData();
  const registry = {};

  for (const font of fonts) {
    // Filter by latin or latin-ext subset
    if (
      !font.subsets.includes("latin") &&
      !font.subsets.includes("latin-ext")
    ) {
      continue;
    }

    // Allow fonts by exact name
    if (!allowedFonts.includes(font.family)) {
      continue;
    }

    try {
      registry[font.family] = parseFontDetails(font);
    } catch {
      // ignore errors on font parsing
    }
  }

  return registry;
};

const constructGoogleFontLinkTags = (fonts) => {
  const preconnectTags =
    '<link rel="preconnect" href="https://fonts.googleapis.com">\n' +
    '<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>\n';

  const prefix = '<link href="https://fonts.googleapis.com/css2?';
  const postfix = 'display=swap" rel="stylesheet">';

  const fontEntries = Object.entries(fonts);
  const chunkSize = 7;
  const linkTags = [];

  for (let i = 0; i < fontEntries.length; i += chunkSize) {
    const chunk = fontEntries.slice(i, i + chunkSize);

    const params = chunk
      .map(([fontName, fontDetails]) => {
        const axes = fontDetails.italics ? ":ital,wght@" : ":wght@";

        let weightParam;
        if ("weights" in fontDetails) {
          // static font, use enumerated weights
          if (fontDetails.italics) {
            weightParam =
              fontDetails.weights.map((w) => `0,${w};`).join("") +
              fontDetails.weights.map((w) => `1,${w};`).join("");
            // remove trailing semicolon
            weightParam = weightParam.slice(0, -1);
          } else {
            weightParam = fontDetails.weights.join(";");
          }
        } else {
          // variable font, use range of weights
          const weightRange =
            fontDetails.minWeight === fontDetails.maxWeight
              ? `${fontDetails.minWeight}`
              : `${fontDetails.minWeight}..${fontDetails.maxWeight}`;
          weightParam = fontDetails.italics
            ? `0,${weightRange};1,${weightRange}`
            : weightRange;
        }

        return "family=" + fontName.replaceAll(" ", "+") + axes + weightParam;
      })
      .join("&");

    linkTags.push(`${prefix}${params}&${postfix}`);
  }

  return preconnectTags + linkTags.join("\n");
};

const generateOutputString = async (registry) => {
  const lines = [
    "// AUTOGENERATED FILE. DO NOT EDIT!",
    "",
    "export const defaultFonts = {",
  ];

  for (const [name, spec] of Object.entries(registry)) {
    lines.push(`  ${JSON.stringify(name)}: ${JSON.stringify(spec)},`);
  }

  lines.push("};\n\n");

  lines.push("export const defaultGoogleFontsLinkTags =");
  // The link tags string contains multiple lines separated by '\n', encode as JS string with literal \n and concatenation
  const linkTags = constructGoogleFontLinkTags(registry);

  const linkTagLines = linkTags.split("\n").map((line, i, arr) => {
    const escapedLine = line.replace(/"/g, '\\"');
    if (i === arr.length - 1) {
      return `  "${escapedLine}";`;
    } else {
      return `  "${escapedLine}\\n" +`;
    }
  });

  lines.push(...linkTagLines);

  return await prettier.format(lines.join("\n"), { parser: "babel" });
};

const main = async () => {
  try {
    const registry = await buildFontRegistry();
    const output = await generateOutputString(registry);

    // ensure the directory exists
    const dir = path.dirname(OUTPUT_FILE);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(OUTPUT_FILE, output, "utf8");
    console.log(`Font registry and link tags saved to ${OUTPUT_FILE}`);
  } catch (error) {
    console.error("Error:", error);
  }
};

main();
