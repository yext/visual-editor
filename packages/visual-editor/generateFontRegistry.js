import fs from "fs";
import path from "path";
import prettier from "prettier";

const GOOGLE_FONTS_API_KEY = process.argv[2]; // Replace with your Google Fonts API key
if (!GOOGLE_FONTS_API_KEY) {
  console.error(
    "Error: No API key provided. Usage: node generateFontRegistry.js YOUR_API_KEY"
  );
  process.exit(1);
}

console.log("Using API key:", GOOGLE_FONTS_API_KEY);

const OUTPUT_FILE = path.join(
  process.cwd(),
  "src",
  "utils",
  "font_registry.js"
);

const BLACKLIST_NAMES = [
  "Wingdings",
  "Wingdings 2",
  "Wingdings 3",
  "Webdings",
  "Symbol",
  "Zapf Dingbats",
  "Marlett",
];

const fallbackFromCategory = (category) => {
  switch (category) {
    case "serif":
      return "serif";
    case "monospace":
      return "monospace";
    case "handwriting":
      return "cursive";
    case "display":
    case "sans-serif":
    default:
      return "sans-serif";
  }
};

const getFontData = async () => {
  const url = `https://www.googleapis.com/webfonts/v1/webfonts?key=${GOOGLE_FONTS_API_KEY}&sort=alpha`;
  const response = await fetch(url);
  if (!response.ok) throw new Error(`API request failed: ${response.status}`);
  const data = await response.json();
  return data.items;
};

const parseFontDetails = (font) => {
  const variants = font.variants;

  const hasItalic = variants.some((v) => v.includes("italic"));

  // Extract weights (some variants are like 'regular' which is 400)
  const weights = variants
    .map((v) => {
      if (v === "regular" || v === "italic") return 400;
      const match = v.match(/^(\d+)/);
      return match ? parseInt(match[1], 10) : NaN;
    })
    .filter((w) => !isNaN(w));

  if (weights.length === 0) {
    weights.push(400);
  }

  const minWeight = Math.min(...weights);
  const maxWeight = Math.max(...weights);

  return {
    italics: hasItalic,
    minWeight,
    maxWeight,
    fallback: fallbackFromCategory(font.category),
  };
};

const buildFontRegistry = async () => {
  const fonts = await getFontData();
  const registry = {};

  for (const font of fonts) {
    // Filter by latin or latin-ext subset
    if (
      !font.subsets.includes("latin") &&
      !font.subsets.includes("latin-ext")
    ) {
      continue;
    }

    // Blacklist nonsense fonts by exact name (case insensitive)
    if (
      BLACKLIST_NAMES.some(
        (name) => font.family.toLowerCase() === name.toLowerCase()
      )
    ) {
      continue;
    }

    try {
      registry[font.family] = parseFontDetails(font);
    } catch {
      // ignore errors on font parsing
    }
  }

  return registry;
};

const constructGoogleFontLinkTags = (fonts) => {
  const preconnectTags =
    '<link rel="preconnect" href="https://fonts.googleapis.com">\n' +
    '<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>\n';

  const prefix = '<link href="https://fonts.googleapis.com/css2?';
  const postfix = 'display=swap" rel="stylesheet">';

  const fontEntries = Object.entries(fonts);
  const chunkSize = 7;
  const linkTags = [];

  for (let i = 0; i < fontEntries.length; i += chunkSize) {
    const chunk = fontEntries.slice(i, i + chunkSize);

    const params = chunk
      .map(([fontName, fontDetails]) => {
        const axes = fontDetails.italics ? ":ital,wght@" : ":wght@";

        // If minWeight === maxWeight, just use the single weight value, else use the range
        const weightRange =
          fontDetails.minWeight === fontDetails.maxWeight
            ? `${fontDetails.minWeight}`
            : `${fontDetails.minWeight}..${fontDetails.maxWeight}`;

        const weightParam = fontDetails.italics
          ? `0,${weightRange};1,${weightRange}`
          : weightRange;

        return "family=" + fontName.replaceAll(" ", "+") + axes + weightParam;
      })
      .join("&");

    linkTags.push(`${prefix}${params}&${postfix}`);
  }

  return preconnectTags + linkTags.join("\n");
};

const generateOutputString = async (registry) => {
  const lines = [
    "// AUTOGENERATED FILE. DO NOT EDIT!",
    "",
    "export const defaultFonts = {",
  ];

  for (const [name, spec] of Object.entries(registry)) {
    lines.push(
      `  ${JSON.stringify(name)}: { italics: ${spec.italics}, minWeight: ${spec.minWeight}, maxWeight: ${spec.maxWeight}, fallback: "${spec.fallback}" },`
    );
  }

  lines.push("};\n\n");

  lines.push("export const defaultGoogleFontsLinkTags =");
  // The link tags string contains multiple lines separated by '\n', encode as JS string with literal \n and concatenation
  const linkTags = constructGoogleFontLinkTags(registry);

  const linkTagLines = linkTags.split("\n").map((line, i, arr) => {
    const escapedLine = line.replace(/"/g, '\\"');
    if (i === arr.length - 1) {
      return `  "${escapedLine}";`;
    } else {
      return `  "${escapedLine}\\n" +`;
    }
  });

  lines.push(...linkTagLines);

  return await prettier.format(lines.join("\n"), { parser: "babel" });
};

const main = async () => {
  try {
    const registry = await buildFontRegistry();
    const output = await generateOutputString(registry);

    // ensure the directory exists
    const dir = path.dirname(OUTPUT_FILE);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(OUTPUT_FILE, output, "utf8");
    console.log(`Font registry and link tags saved to ${OUTPUT_FILE}`);
  } catch (error) {
    console.error("Error:", error);
  }
};

main();
